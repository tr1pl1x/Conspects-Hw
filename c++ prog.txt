05.09
1 #include <stdio.h> с решетки начинается директива препроцессора (включить файл, который в треуг скобках) 
Чтобы общаться с пользователем, нужно подключить библиотеку 
Все файлы стандартной бибилиотеки подключаются через треуг скобки
Одна строка - одна директива
2 Пустая строка - дань традициям
3 int main() главная функция программы. В каждой программе на С есть только одна функция main. Main - точка входа программы
4 { тело функции (блок кода)
5 printf("Hello world!\n"); \n - символ перехода на новую строку
6 return 0; вернуться в точку входа. Возврат управления в точку вызова. 0 - успех
7 }

Код, написанный на С нуждается в переводе на машинный язык. Для этого требуется три программы:
1. препроцесор. Выполняет директивы прероцессора. Директива начинается с решетки, в конце директивы точка с запятой не ставится. Получаем другой текст файл, написанный на языке С
2. компилятор. Ищет синтаксические ошибки в файле препроцессора. После чего текстовый файл переводится в объектный файл .obj
3. линковщик (сброщик). Собирает объектные файлы в единый исполняемый файл. 1ый объектный файл поставляется с компилятором, а 2ой от компилятора.

#define - определение макроса
#define TASK_2
#ifdef TASK_1
...
#endif
Будет ошибка, т.к. TASK_1 неактивный блок препроцессора

int a = 0, b = 0; - если не инициализировали переменную, там лежит мусор, поэтому всегда нужно инициализировать переменные (a = 0)!!!

scanf("%d%d", &a, &b); - сканировщик ввода, два целых числа. Амперсант = адрес

#define _CRT_SECURE_NO_WARNINGS - остановка предупреждений от майкрософт. Пишется в начале

printf("Summa is %d\n", a + b);

double a = 0, b = 0;
scanf("%lf%lf", &a, &b);
printf("Summa is %.2lf\n", a + b);

cppreference - справочник форматов и языка

#define _USE_MATH_DEFINES
#include <math.h> - математическая библиотека
int main()
{
    double rad = 0;
    scanf("%lf", &rad);
    printf("%lf\n", 4.0/3 * M_PI * pow(rad, 3));
}

В контестах писать 3.14!!!


19.09
отрицание - !
лог И - &&
лог ИЛИ - ||

Ленивая семантика (при известном результате компилятор не дойдет до второй функции)

10<x<30 (т.к. 10<x = 1 функция не доходит до 30) - неверно
Поэтому if(-30<x && x<-10)

Присваивание (справа налево) - самый низкий приоритет. То, что стоит справа - имеет значение. Слева не должна быть константа, должна быть постоянная память
То, что стоит слева - изменяется a+b = c
a *= b+5 (b+5 приоритет становится выше, выполняется первым)

Унарные операции ++ --:
- изменяют операнды
- две формы (префикс -без копии (быстрее), постфикс - временная копия)
- выполняются справа налево
- высокий приоритет 
- унарный минус умножает на (-1), а плюс на 1
- ++ увеличивает на 1, -- уменьшает на 1 
У a есть адрес, значение, память и т.д.. ++a идем в а по адресу, увеличиваем и записываем туда же. а++ идем в а по адресу, создаем копию (без адреса, она не в памяти, в регистрах процессора, будет уничтожена) и добавляем 1 к исходной а. На экран выводится временная копия.

Тернарная операция
- приоритет выше присваивания
- ленивая семантика (работает только одна часть)
a>5 ? a:5

